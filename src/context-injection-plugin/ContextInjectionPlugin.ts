import Compiler = require('webpack/lib/Compiler');
import ContextDependency = require('webpack/lib/dependencies/ContextDependency');
import ConcatSource = require('webpack-sources/lib/ConcatSource');
import ReplaceSource = require('webpack-sources/lib/ReplaceSource');
import NormalModule = require('webpack/lib/NormalModule');

export interface ContextInjectionPluginOptions {
	/**
	 * An array of directory paths whose modules (one-level deep) should be included in the build.
	 */
	contexts: string[];

	/**
	 * The ID of the module containing a down-emitted `import()` that needs to be replaced. A regular
	 * expression can be used to match multiple modules.
	 */
	mid: string | RegExp;
}

export interface TsImportDependencyOptions {
	context: string;
	group: GroupedImportsDependency;
}

/**
 * A webpack plugin that converts down-emitted `import()` calls to context requires.
 *
 * The general approach can be summarized as follows:
 * 1. Create an empty map of webpack mids to contexts. Each mid in this map corresponds to a context require
 *    generated by webpack that can load modules from that context. For more on contexts, see
 *    https://webpack.js.org/guides/dependency-management/#require-context
 * 2. Create a dependency for each specified context. Each dependency populates a map with its own webpack mid
 *    and ensures the `require` calls generated from down-emitted `import()` calls are replaced with the custom
 *    `__dynamicRequire__` function.
 * 3. Inject the map created in step 1 into a template that contains the `__dynamicRequire__` function used
 *    to dynamically resolve string mids to webpack mids.
 * 4. Inject the template from step 3 into the specified module containing down-emitted `import()` calls.
 */
export class ContextInjectionPlugin {
	readonly contexts: string[];
	readonly group: GroupedImportsDependency;
	readonly mid: RegExp;

	constructor({ contexts, mid }: ContextInjectionPluginOptions) {
		this.contexts = contexts;
		this.mid = typeof mid === 'string' ? new RegExp(mid) : mid;
		this.group = new GroupedImportsDependency(contexts);
	}

	/**
	 * Generate dependencies for each context and inject them into the build, using a map to match string mids to their
	 * corresponding webpack mids.
	 *
	 * @param compiler The webpack compiler
	 */
	apply(compiler: Compiler) {
		compiler.plugin('compilation', (compilation, params) => {
			const contextModuleFactory = params.contextModuleFactory;

			compilation.dependencyFactories.set(TsImportDependency as any, contextModuleFactory);
			compilation.dependencyTemplates.set(TsImportDependency as any, new TsImportDependencyTemplate());

			compilation.moduleTemplate.plugin('module', (source, module: NormalModule) => {
				const { request = '' } = module;
				if (this.mid.test(request)) {
					return new ConcatSource(this.group.loaderTemplate, '\n', source);
				}
				return source;
			});

			params.normalModuleFactory.plugin('parser', (parser) => {
				parser.plugin('call require', (expr) => {
					const module = parser.state.current as NormalModule;
					const request = module && module.request || '';

					if (this.mid.test(request) && this.isDynamicRequire(expr)) {
						this.group.addRange(expr.range);
						this.group.addModuleDependencies(parser.state.current as NormalModule);

						return true;
					}
				});
			});
		});
	}

	/**
	 * @private
	 * Determine whether a require call is loading a resource dynamically.
	 *
	 * @param expr An ast node for a require call.
	 * @return `true` if the require is dynamic; `false` if it is static.
	 */
	private isDynamicRequire(expr: any): boolean {
		let mid = expr.arguments[0];
		let type = mid.type.toLowerCase();

		if (type === 'arrayexpression') {
			mid = mid.elements[0];

			if (!mid) {
				return false;
			}

			type = mid.type.toLowerCase();
		}

		return type !== 'literal';
	}
}

/**
 * A template that is injected into a module with a down-emitted `import()`. The resulting function matches
 * a string mid to a context require, and then uses that context require to load the desired module. The function
 * expects a string mid, but can also take a promise resolver and rejector as its second and third arguments,
 * respectively.
 */
const loaderTemplate = `var __dynamicImport__ = (function () {
	var webpackRequire = {{webpackRequire}};
	var contextsById = {{contextsById}};
	return function (mid, resolve, reject) {
		var webpackRequireError;
		for (var id in contextsById) {
			var context = contextsById[id];
			if (context && mid.indexOf(context) === 0) {
				var contextRequire = webpackRequire(Number(id));
				try {
					var module = contextRequire('./' + mid.replace(context, ''));
					resolve && resolve(module);
					return module;
				}
				catch (error) {
					webpackRequireError = error;
				}
			}
		}

		var error = webpackRequireError || new Error('Missing module: ' + mid);
		if (reject) {
			reject(error);
		}
		else {
			throw new Error('Missing module: ' + mid);
		}
	};
})();`;

/**
 * A context dependency manager that ensures down-emittted `import()` calls are replaced with a custom require that
 * matches mids to context requires.
 */
export class GroupedImportsDependency {
	private contextsById: { [key: number]: string } = Object.create(null);
	private dependencies: TsImportDependency[];
	private ranges: [ number, number ][];
	private sourceReplaced = false;

	readonly contexts: string[];

	/**
	 * The string template injected into the module containing the down-emitted `import()` to be replaced.
	 */
	get loaderTemplate() {
		return loaderTemplate
			.replace('{{contextsById}}', JSON.stringify(this.contextsById))
			.replace('{{webpackRequire}}', '__webpack_require__');
	}

	constructor(contexts: string[]) {
		this.contexts = contexts;
		this.createDependencies();
		this.ranges = [];
	}

	/**
	 * Add a dependency for each context to the specified module.
	 *
	 * @param module The module object whose source contains the down-emitted `import()`.
	 */
	addModuleDependencies(module: NormalModule) {
		this.dependencies.forEach(dependecy => {
			module.addDependency(dependecy);
		});
	}

	/**
	 * Add a range representing the source location of a `require` call down-emitted from an `import()`.
	 *
	 * @param range The range for the `require` call to replace.
	 */
	addRange(range: [ number, number ]) {
		this.ranges.push(range);
	}

	/**
	 * Replace all dynamic requires in the specified source with a custom require that can correctly load modules
	 * dynamically from a root context.
	 *
	 * @param source The source to replace.
	 */
	replaceSourceRequire(source: ReplaceSource) {
		if (!this.ranges.length || this.sourceReplaced) {
			return;
		}

		this.sourceReplaced = true;
		this.ranges.forEach(([ start, end ]) => {
			const argsPattern = /^\w+\(([^)]+)\)$/;
			const arrayPattern = /\[\s?([a-z0-9_]+)\s?\]/i;
			const requireString = source.original().source().slice(start, end).trim();
			const args = requireString.replace(argsPattern, '$1').replace(arrayPattern, '$1');
			const content = `__dynamicImport__(${args})`;

			source.replace(start, end - 1, content);
		});
	}

	/**
	 * Set the webpack mid for a context.
	 *
	 * @param context The context path.
	 * @param id The webpack mid.
	 */
	setContextRequireId(context: string, id: number) {
		if (context.lastIndexOf('/') !== context.length - 1) {
			context += '/';
		}
		this.contextsById[id] = context;
	}

	/**
	 * @private
	 * Create a dependency for each context.
	 */
	private createDependencies() {
		const group = this;
		this.dependencies = this.contexts.map(context => new TsImportDependency({ context, group }));
	}
}

/**
 * A simple webpack dependency that ensures a webpack mid is created for its context and ensures its modules
 * can be required.
 */
export class TsImportDependency extends ContextDependency {
	readonly group: GroupedImportsDependency;

	/**
	 * An alias for the `request` property, which is the common property name used across webpack dependencies.
	 */
	get context() {
		return this.request;
	}

	constructor({ context, group }: TsImportDependencyOptions) {
		super(context, false, /^\.\//);
		this.group = group;
	}

	/**
	 * Set the webpack mid for the generated context module.
	 *
	 * @param id The webpack mid.
	 */
	registerId(id: number) {
		const { context, group } = this;
		group.setContextRequireId(context, id);
	}

	/**
	 * Replace down-emitted `import()` calls in the specified source with a custom require that can load modules
	 * from the dependency's context.
	 *
	 * @param source The source to replace.
	 */
	replaceSource(source: ReplaceSource) {
		this.group.replaceSourceRequire(source);
	}
}

/**
 * A custom template that replaces down-emitted `import()` calls with a custom context require.
 */
export class TsImportDependencyTemplate {
	/**
	 * Replace down-emitted `import()` calls within the specified source with a custom context require.
	 *
	 * @param dep The context dependency.
	 * @param source The source to replace.
	 */
	apply(dep: TsImportDependency, source: ReplaceSource) {
		dep.registerId(dep.module && dep.module.id);
		dep.replaceSource(source);
	}
}

export default ContextInjectionPlugin;
