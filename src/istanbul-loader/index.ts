import { loader } from 'webpack';
import { createInstrumenter } from 'istanbul-lib-instrument';
import { getOptions } from 'loader-utils';
import { RawSourceMap, MappedPosition, MappingItem, SourceMapConsumer, SourceMapGenerator } from 'source-map';

/**
 * Instrument a source file with istanbul for code coverage.
 *
 * Instrumenter options will be read from the project 'intern.json' file.
 *
 * @param content the source code
 * @param sourceMap an optional source map
 */
export default <loader.Loader>function(source: string | Buffer, sourceMap?: any) {
	const callback = this.async()!;
	const options = ({ ...getOptions(this) } || {}) as any;

	const _sourceMap = <RawSourceMap>sourceMap;
	const instrumenterOptions = {
		produceSourceMap: true,
		...(options.instrumenterOptions || {})
	};

	if (options.coverageVariable) {
		instrumenterOptions.coverageVariable = options.coverageVariable;
	}

	const instrumenter = createInstrumenter(instrumenterOptions);

	// For the code coverage to work we need to modify the sources in the
	// source map to point back to the original file. The files coming in have
	// been generated by webpack and look like,
	// "node_modules/tslint-loader?!path/to/file/css-modules!path/to/file.ts.
	// We need these files to simply be "path/to/file.ts".
	if (_sourceMap) {
		_sourceMap.sources = (_sourceMap.sources || []).map((source) => {
			const lastBang = source.lastIndexOf('!');
			if (lastBang !== -1) {
				return source.substr(lastBang + 1);
			}
			return source;
		});
	}

	instrumenter.instrument(
		String(source),
		this.resourcePath,
		(error, instrumentedSource) => {
			if (error) {
				callback(error);
			} else {
				try {
					const instrumentedSourceMap = instrumenter.lastSourceMap();
					let updatedSourceMap: RawSourceMap;
					if (_sourceMap) {
						updatedSourceMap = mergeSourceMaps(instrumentedSourceMap, _sourceMap);
					} else {
						updatedSourceMap = instrumentedSourceMap;
					}

					callback(null, instrumentedSource, <any>updatedSourceMap);
				} catch (err) {
					callback(err);
				}
			}
		},
		_sourceMap
	);
};

/**
 * Merge a list of source maps generated through successive transforms of a
 * single file.
 *
 * Maps should be in reverse order (i.e., the first map should be
 * from the most recent transform).
 *
 * @param maps an array of raw source maps in order from the most recently
 * generated map to the original map
 * @returns a source map that maps locations in the final transformed file to
 * the original file
 */
function mergeSourceMaps(...maps: RawSourceMap[]) {
	const consumers = maps.map((map) => new SourceMapConsumer(map));
	const generator = new SourceMapGenerator({ file: maps[0].file });

	// Walk through each mapping of the most recent source map
	consumers[0].eachMapping((mapping) => {
		const original = getOriginalPosition(consumers, mapping);
		if (original.line !== null) {
			generator.addMapping({
				generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn!
				},
				original: {
					line: original.line,
					column: original.column!
				},
				source: mapping.source!,
				name: mapping.name
			});
		}
	});

	return <RawSourceMap>JSON.parse(generator.toString());
}

/**
 * Find the original position for a given position.
 *
 * @param consumers a list of source map consumers, from the most recently
 * generated to the original
 * @param mapping a mapping item from the most recent source map
 * @returns a position in the original file
 */
function getOriginalPosition(consumers: SourceMapConsumer[], mapping: MappingItem) {
	return consumers.reduce(
		(original, consumer) => {
			// Ignore missing mappings
			if (isMappedPosition(original)) {
				return consumer.originalPositionFor(original);
			}
			return original;
		},
		{
			line: mapping.generatedLine,
			column: mapping.generatedColumn
		}
	);
}

/**
 * Indicate whether the given value is a MappedPosition
 */
function isMappedPosition(position: any): position is MappedPosition {
	return position.line != null && position.column != null && position.source != null;
}
